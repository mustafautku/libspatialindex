Installation Instructions
*************************

Copyright (C) 1994-2020 Free
Software Foundation, Inc.

This file is free documentation; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.

Basic Installation
==================

These are generic installation instructions.

   If you need to do unusual things to compile the package, please try
to figure out how `cmake' could check whether to do them, and mail
diffs or instructions to the address given in the `README' or send 
a pull request so they can be considered for the next release.

The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `cmake .' to check and generate a `Makefile` for your system.

  2. Type `make' to compile the package. You also can increase the compiling speed by `make ${nproc:-8}'.

  3. Type `make install' to install the programs and any data files and
     documentation.

  4. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  To also remove the
     files that `cmake' created, you need to remove them manually.

Compilers and Options
=====================

Some systems require unusual options for compilation or linking that the
`cmake' does not know about.  Check [CMake Properties](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html) for
details on some of the pertinent environment variables.
*Note: not all `cmake' variables can be applicable in this `CMakeLists' file.

   You can give `cmake' initial values for configuration parameters
by setting variables in the command line or in the environment.  Here
is an example:

     cmake . -DCMAKE_CXX_COMPILER_ID=Intel 

or by environment variables:

   CMAKE_CXX_COMPILER_ID=Intel cmake .

   *Note Defining Variables::, for more details.

will cause the specified compiler ID to be used as the C++ compiler.

Compiling For Multiple Architectures
====================================

You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you must use a version of `make' that
supports the `VPATH' variable, such as GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `cmake'.  `cmake' automatically checks for the
source code in the directory that `CMakeLists.txt' is in.

   If you have to use a `make' that does not support the `VPATH'
variable, you have to compile the package for one architecture at a
time in the source code directory.  After you have installed the
package for one architecture, use `make clean' and remove `cmake-generated'
files before reconfiguring for another architecture.

Installation Names
==================

By default, `make install' will install the package's files in
`/usr/local/bin', `/usr/local/man', etc. You can specify an
installation prefix other than `/usr/local' by giving `cmake' the
option `-B PREFIX'.  Here is an example:

      cmake . -B /home/user1/my-build/

****************************************************************
I have 2 libspatialindex library, one is in system-level the other is in private.
   1- ) dpkg -l | grep spatialindex
         ii  libspatialindex-c6:amd64           1.9.3-2                                 amd64        General framework for developing spatial indices - C library
   2- ) see the version in root/CMakeLists.txt:
         project(spatialindex
            LANGUAGES CXX
            VERSION "2.1.0"
            HOMEPAGE_URL "https://github.com/libspatialindex/libspatialindex"
      )
************* I have Build_library.sh, Build_tests.sh and Build_active.sh scripts to automate the build process. *************

Build_library.sh  :::  you have task labeled as "_build: CMake config & Build & Install libspatialindex LIBRARY" in .vscode/tasks.json.
------------------
1. yol( en basit): 
   ~/projeler/libspatialindex$ cmake . -Bmybuild -DCMAKE_INSTALL_PREFIX=$HOME/PROGRAMMING/libspatialindex -DCMAKE_BUILD_TYPE=Debug
         cmake â€” Invokes the CMake configuration tool.
         . â€” Specifies the current directory as the source directory (where the CMakeLists.txt file is).
         -Bmybuild â€” Tells CMake to generate all build files (like Makefile, CMakeCache.txt, etc.) in a new directory called mybuild.
               --> This makes ${CMAKE_BINARY_DIR} as mybuild.
         -DCMAKE_INSTALL_PREFIX=$HOME/PROGRAMMING/libspatialindex â€” Sets the custom installation path to your PROGRAMMING directory under your home folder.

2.yol: Fakat bu yukardaki 1. yoldaki cmake config yerine aÅŸaÄŸÄ±daki test ortamÄ± iÃ§in daha iyi:
   ~/projeler/libspatialindex$cmake -S . -B mybuild \
      -DCMAKE_INSTALL_PREFIX=$HOME/PROGRAMMING/libspatialindex \
      -DCMAKE_BUILD_TYPE=Debug \
      -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \
      -DCMAKE_INSTALL_RPATH=$HOME/PROGRAMMING/libspatialindex/lib \
      -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=FALSE
      Dinamik linker (ld.so) .so dosyalarÄ±nÄ± sadece ÅŸu dizinde arayacak: /home/mustafautku/PROGRAMMING/libspatialindex/lib
      BaÅŸka hiÃ§bir yere (Ã¶rneÄŸin /usr/lib, /usr/local/lib, vs.) gitmeyecek.
      LD_LIBRARY_PATH bile override edemez, Ã§Ã¼nkÃ¼ RUNPATH buna izin vermez 
               (sadece RPATH bunu engellerdi, ama sende USE_LINK_PATH=FALSE sayesinde fallback yok).
      MEsela: 
         PROGRAMMING/libspatialindex/lib silinirse â†’ binary Ã§alÄ±ÅŸmaz

   ~/projeler/libspatialindex$ cmake --build mybuild -j$(nproc)         # Compiles the project
   ~/projeler/libspatialindex$ cmake --install mybuild                  # Installs it to $HOME/PROGRAMMING/libspatialindex

   libspatialindex$ readelf -d mybuild/test/test-rtree-Generator | grep -i path
      0x000000000000001d (RUNPATH)            Library runpath: [/home/mustafautku/PROGRAMMING/libspatialindex/lib]
      yani bakacagi dynamic library path binary icine gÃ¶mÃ¼lÃ¼ ve baÅŸka yerde de aramayacak!!

   Bu sayede (yani 2. yol ile) task veya launch config'lerde "LD_LIBRARY_PATH": "${env:HOME}/PROGRAMMING/libspatialindex/lib" ihtiyac kalmamis oldu..
   FAKAT, bu sefer gtest calismiyor. mybuild/libsidxtest calismasÄ± iÃ§in mybuild/lib altÄ±ndaki libgtest.so.1.14.0 i bulmasÄ± gerek.
   Bunlari PROGRAMMING/libspatialindex e install etmedik, cunku bu harici bir sey..
   O zaman bu mevcut (2.yol) cmake setting inde, gtest de calismasÄ± iÃ§in 2 yol var:
   1) libspatialindex/mybuild/bin$ LD_LIBRARY_PATH=../lib ./libsidxtest
   2) bu mevcut (2.yol) cmake setting inde DCMAKE_INSTALL_RPATH i asagidaki gibi gÃ¼ncellemek..
      -DCMAKE_INSTALL_RPATH="$HOME/PROGRAMMING/libspatialindex/lib;$HOME/projeler/libspatialindex/mybuild/lib"
      bu durumda hem library nini kendi tesleri hem gtest calisacak..
   O zaman son hali soyle:
   cmake -S . -B mybuild \
    -DCMAKE_INSTALL_PREFIX=$HOME/PROGRAMMING/libspatialindex \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \
    -DCMAKE_INSTALL_RPATH="$HOME/PROGRAMMING/libspatialindex/lib;$HOME/projeler/libspatialindex/mybuild/lib" \
    -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=FALSE
   cmake --build mybuild -j$(nproc)         # Compiles the project
   cmake --install mybuild                  # Installs it to $HOME/PROGRAMMING/libspatialindex




build_tests.sh ::::   you have task labeled as "_build: Build libspatialindex tests" in .vscode/tasks.json.
--------------------
   # If you want to build the library's executables in a different directory, you can do it like in build_tests.s
   # FAKAT BUNA GEREK YOK. Cunku root dizindeki CMakeLists.txt icinde 
   #if(BUILD_TESTING)
   #   add_subdirectory(test)
   # endif()
   # olduÄŸu iÃ§in root/mybuild/test altÄ±nda executable dosyalarÄ± olusuyor.
   Bu asagidaki de calistirsan bu sefer root/test/mybuild altÄ±nda da executable dosyalarÄ± olusacak..GEREK YOK.
   ~/projeler/libspatialindex/test$ mkdir mybuild && cd mybuild
   mustafautku@DESKTOP-8QI17KG:~/projeler/libspatialindex/test/mybuild$ ls
   mustafautku@DESKTOP-8QI17KG:~/projeler/libspatialindex/test/mybuild$ cmake .. \
      -DCMAKE_BUILD_TYPE=Debug \
   -DCMAKE_PREFIX_PATH=$HOME/PROGRAMMING/libspatialindex \
   -DCMAKE_INSTALL_RPATH=$HOME/PROGRAMMING/libspatialindex/lib \
   -DCMAKE_EXE_LINKER_FLAGS="-L$HOME/PROGRAMMING/libspatialindex/lib -Wl,-rpath=$HOME/PROGRAMMING/libspatialindex/lib" \
   -DCMAKE_SHARED_LINKER_FLAGS="-L$HOME/PROGRAMMING/libspatialindex/lib -Wl,-rpath=$HOME/PROGRAMMING/libspatialindex/lib"
   mustafautku@DESKTOP-8QI17KG:~/projeler/libspatialindex/test/mybuild$ make -j$(nproc)


Build_active.sh :::    you have task labeled as "_build: Build Active TEST File with CMake Target" in .vscode/tasks.json.
-------------------------
   EÄŸer test dizinindeki tek bir testi hizlica derlemek istersen: mybuild dizininde ÅŸunu yapabilirsin:
   cmake --build . --target my_test_binary_name


*************************************************
-- modify a single test  --> run task labeled "_build: Build Active TEST File with CMake Target"

modify library's src  --> run task labeled as "_build: build-and-install-libspatialindex"
   includes "make" and "make install". no need to cmake config..

if you delete mybuild directory, you can run the task labeled as "_build: CMake config & Build & Install libspatialindex LIBRARY" in .vscode/tasks.json to regenerate it.

task.json'da "kind": "build" olan ve Build_library.sh ile library build edilirken aÅŸaÄŸÄ±daki set Ã¶nemli, ta ki system-wide kurulmasÄ±n..Cunku system-wide kullananlar python-rtree, QGIS..
cmake . -Bmybuild -DCMAKE_INSTALL_PREFIX=$HOME/PROGRAMMING/libspatialindex

task.json'da "kind": "test" olan yani execution teslerde aÅŸaÄŸÄ±daki set Ã¶nemli..ta ki system-wide libspatialindex lib dosyalari kullanilmasin..
"LD_LIBRARY_PATH": "${env:HOME}/PROGRAMMING/libspatialindex/lib"

************************************************,
F5 -->
   bu komut launch.json ile ilgili..run veya debug yapmak icin..
   Visual Studio Code'da sol Ã¼stteki debug configuration dropdown menÃ¼sÃ¼, .vscode/launch.json dosyasindaki 
   tanimli tÃ¼m debug yapilandirmalarini listeler.
   ğŸ” O listede:
   "name": "..." alanina yazdigim her ÅŸey orada gÃ¶rÃ¼nÃ¼r.
   listeden hangisini seÃ§iliyse F5 tuÅŸuna basildiÄŸinda  veya "Run > Start Debugging" dediÄŸinizde, sadece onu Ã§alÄ±ÅŸtirir.

Ctl- Shift + B   --> sadece build icin..
   bu komut task.json ile ilgili..
   "group": {
				"kind": "build",
				"isDefault": true
			}
   bu gruptaki tÃ¼m isDefault olan task'larÄ± top-drop down listede listeler..Su anda 2 tane var:
      _build: build-and-install-libspatialindex   --> library src deÄŸiÅŸtirdiysen
      _build: Build Active TEST File with CMake Target  --> test src deÄŸiÅŸtirdiysen

Her test (Exhaustive, Generator, RTreeeLoad, RtreeBulkLoad, RTreeQuery) farkli argumanlar ile Ã§aliÅŸtiÄŸi iÃ§in 
farkli task veya launch tanimi yapmam gerekiyor..

Ctl + Shift + P  -->
   bu komut da top-command palette ile ilgili..
   "Run Task" yazinca, task.json'daki tÃ¼m task'lari listeler.
   oradan istediÄŸini seÃ§ip Ã§aliÅŸtirabilirsin.



********************************************
CTest:
   test/CMakeLists.txt deki add_test(...), yeni bir "ctest" testi ekliyor. Bu sayede mybuild ve mybuild/test
   dizinlerinde CTestTestfile.cmake dosyalarÄ± olustu. 
   mybuild/ veya mybuild/test altÄ±nda asaÄŸidaki komutlar ile ctest yapilmis oluyor.
   mybuild$ ctest -V  --> butun testleri calistiriyor. detayli dÃ¶kÃ¼m..verbose..
   mybuild$ ctest index-tests   --> sadece index-tests isimli tanÄ±mlanan testi calistirir. verbose deÄŸil..
   libspatialindex/mybuild$ ctest -V -R mytest1   --> sadece mytest1 verbose calistir..mytest1 test/CMakeLists.txt de tanÄ±mlandÄ±..

   Bu asagidaki mytest1 i test/CMakeLists.txt ye ben ekledim..
   add_test(NAME mytest1
             COMMAND /bin/sh "${CMAKE_CURRENT_SOURCE_DIR}/rtree/test0/run"
             WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/test)     ---> mybuild/test altÄ±nda dat idx ve diger temp file olusacak..
    set_property(TEST mytest1 PROPERTY ENVIRONMENT
             "PATH=${CMAKE_BINARY_DIR}/test/:$ENV{PATH}")     ---> mybuild/test altÄ±ndaki executable lari kullanÄ±yor..belki install etmediysek gene calissin..

gtest:
   The following runs the gtest. for debugging there is a correspoanding config "name": "Debug libsidxtest" in the launch.json
   /libspatialindex/mybuild/bin$ ./libsidxtest 